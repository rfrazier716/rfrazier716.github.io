<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rendering Constructive Solid Geometry With Python | Fotonix &amp; Gizmo</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://rfrazier716.github.io/posts/efficient-csg/">
<link rel="icon" href="../../favicon.ico" sizes="16x16">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Ryan Frazier">
<link rel="prev" href="../getting-up-and-running-with-nikola/" title="Getting Up and Running with Nikola" type="text/html">
<meta property="og:site_name" content="Fotonix &amp; Gizmo">
<meta property="og:title" content="Rendering Constructive Solid Geometry With Python">
<meta property="og:url" content="https://rfrazier716.github.io/posts/efficient-csg/">
<meta property="og:description" content="I recently hit a road block with my ray tracer: cubes, cylinders, and spheres rendered fine, but there wasn't an easy way to create arbitrary shapes whose intersection and normal functions I hadn't al">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-03-15T07:35:26-04:00">
<meta property="article:tag" content="constructive solid geometry">
<meta property="article:tag" content="csg">
<meta property="article:tag" content="numpy">
<meta property="article:tag" content="pyrayt">
<meta property="article:tag" content="python">
<meta property="article:tag" content="ray tracing">
<meta property="article:tag" content="rendering">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">Fotonix &amp; Gizmo</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../" class="nav-link">Home</a>
                </li>
<li class="nav-item">
<a href="../../projects/" class="nav-link">Projects</a>
                </li>
<li class="nav-item">
<a href="../" class="nav-link">Blog</a>
                </li>
<li class="nav-item">
<a href="../../about/" class="nav-link">About</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Rendering Constructive Solid Geometry With Python</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Ryan Frazier
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2021-03-15T07:35:26-04:00" itemprop="datePublished" title="2021-03-15 07:35">2021-03-15 07:35</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>I recently hit a road block with my <a class="reference external" href="https://github.com/rfrazier716/PyRayT">ray tracer</a>: cubes, cylinders, and spheres rendered fine, but there wasn't an easy way to create arbitrary shapes whose intersection and normal functions I hadn't already hard coded. Since <a class="reference external" href="https://github.com/rfrazier716/PyRayT">PyRayT's</a> end use is for optical design, at the bare minimum it needed a flexible way to create lenses and mirrors. Flipping through Jamis Bucks' <a class="reference external" href="https://pragprog.com/titles/jbtracer/the-ray-tracer-challenge/">The Ray Tracer Challenge</a>, it turns out the last chapter <em>Constructive Solid Geometry</em> (CSG) addressed my needs perfectly! However, Buck's equations for CSG did not blend well with PyRayTs flow of rendering multiple rays at once. Today I'll be covering my own algorithm for adding constructive solid geometry to a ray tracer, as well as its implementation in Python using <a class="reference external" href="https://numpy.org">NumPy</a>.</p>
<!-- TEASER_END -->
<div class="contents alert alert-primary col-md-4 topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li>
<p><a class="reference internal" href="#csg-in-a-nutshell" id="id2">CSG In a Nutshell</a></p>
<ul>
<li><p><a class="reference internal" href="#what-it-means-for-ray-tracing" id="id3">What It Means for Ray Tracing</a></p></li>
</ul>
</li>
<li>
<p><a class="reference internal" href="#writing-a-function-to-filter-hits" id="id4">Writing a Function to Filter Hits</a></p>
<ul>
<li><p><a class="reference internal" href="#the-surface-count-vector" id="id5">The surface_count Vector</a></p></li>
<li><p><a class="reference internal" href="#union" id="id6">Union</a></p></li>
<li><p><a class="reference internal" href="#intersection" id="id7">Intersection</a></p></li>
<li><p><a class="reference internal" href="#difference" id="id8">Difference</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id9">Extending To 2D Matrices</a></p></li>
</ul>
</li>
<li>
<p><a class="reference internal" href="#the-full-function" id="id10">The Full Function</a></p>
<ul>
<li><p><a class="reference internal" href="#verifying-test-cases" id="id11">Verifying Test Cases</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="csg-in-a-nutshell">
<h2><a class="toc-backref" href="#id2">CSG In a Nutshell</a></h2>
<p>An easy way to create complex surfaces from basic shapes, constructive solid geometry is based around three fundamental operations: union, intersect, and difference. Each operation acts on two shapes, resulting in a new shape that is a combination of the two. Multiple CSG operations can be chained together, creating increasingly intricate shapes while using significantly less surfaces than an equivalent triangular mesh.</p>
<div class="figure align-center">
<img alt="/images/efficient_csg/csg_operations.png" src="../../images/efficient_csg/csg_operations.png" style="width: 800px;"><p class="caption">The three base operations for Constructive Solid Geometry. <strong>Union (∪)</strong> combines both shapes, <strong>intersection (∩)</strong> returns only the common volume of both spaces, and <strong>difference (-)</strong> subtracts the second shape from the first.</p>
</div>
<div class="section" id="what-it-means-for-ray-tracing">
<h3><a class="toc-backref" href="#id3">What It Means for Ray Tracing</a></h3>
<p>Ray tracing with CSG's is surprisingly straightforward. When a ray is interesected with a CSG object, it is really intersected with the set of surfaces that make up the object. The job of the CSG algorithm is to take those two sets of intersections and filter them out so that only valid ones remain. These hits are then returned to the renderer so it can determine the closest surface that the ray interacts with.</p>
<div class="figure align-center">
<img alt="/images/efficient_csg/example_hits.png" src="../../images/efficient_csg/example_hits.png" style="width: 600px;"><p class="caption">An example of rendering the union of two surfaces. While each sub-shape returns a full set of intersections, the filter function discards points a1 and b0 since they are inside of the new object.</p>
</div>
<p>Writing a function to sort valid CSG hits turns out to be nontrivial. For every ray-surface hit, the function needs to determine if the hit occurred inside the opposite surface. This is easy enough for convex surfaces that have at most two intersections per ray, but as the number of intersections grows, basic methods for filtering fall apart or slow down significantly.</p>
<div class="figure align-center">
<img alt="/images/efficient_csg/csg_timeline.png" src="../../images/efficient_csg/csg_timeline.png" style="width: 500px;"><p class="caption">Complex hit arrays for two surfaces A &amp; B, and the expected hit arrays for CSG Operations on those surfaces</p>
</div>
</div>
</div>
<div class="section" id="writing-a-function-to-filter-hits">
<h2><a class="toc-backref" href="#id4">Writing a Function to Filter Hits</a></h2>
<p>Every method I found to filter out csg intersections involved iterating over all hits in a set, and internally keeping track of two booleans that determine if the ray is inside of each surface at a given hit. By contrast, this approach operates on the entire array at once, but leverages a few assumptions about the surfaces being intersected:</p>
<ul>
<li><dl>
<dt>Both surfaces are closed surfaces</dt>
<dd>
<p><em>"A closed surface is a surface that is compact and without boundary."</em> While this definition is accurate, it's not exactly intuitive to imagine what surfaces are closed and which are open. I visualize closed surfaces as "if I were to look at this surface from any angle, can I tell if it's hollow without cutting it open". If the answer is no, it's closed, otherwise it's an open surface with a boundary.</p>
<p>By asserting that all surfaces are closed surfaces, you can also claim that <strong>each hit array has an even number of elements</strong>. Since rays extend from time <span class="math">\(t=-\infty\)</span> to <span class="math">\(t=\infty\)</span>, any ray that enters a surface <em>must</em> exit the surface. Even if the surface has infinite volume, the ray will then enter and exit at <span class="math">\(\mp\infty\)</span>.</p>
<p>Additionally, CSG becomes meaningless if the surfaces are not closed. Imagine subtracting an infinitely thin plane from a sphere. Since planes have no depth you don't remove any material from the sphere, and end with the same shape you started with!</p>
</dd>
</dl></li>
<li><dl class="simple">
<dt>The hit arrays are sorted</dt>
<dd>
<p>We'll use the position of intersections in their respective arrays to determine if the ray is entering or exiting the surface. In order for it to work, both input arrays must be sorted.</p>
</dd>
</dl></li>
<li><dl class="simple">
<dt>Odd indexed hits enter the surface, even valued hits leave the surface</dt>
<dd>
<p>Since the intersection arrays are sorted, and include all hits from <span class="math">\(-\infty\)</span> to <span class="math">\(\infty\)</span>, the first element each hit array <em>must</em> be the ray entering the respective surface. Additionally, it's impossible for the ray to enter the surface again without first leaving it, so the next hit represents the ray exiting the surface. This alternating pattern continues for the entire hit array.</p>
</dd>
</dl></li>
</ul>
<div class="section" id="the-surface-count-vector">
<h3><a class="toc-backref" href="#id5">The surface_count Vector</a></h3>
<p>There are two additional arrays we'll use validate hits: (1) a sorted array of all hits for both surfaces, and (2) an array that tracks how many surfaces the ray is inside of at each hit, called surface_count.</p>
<div class="figure align-center">
<img alt="/images/efficient_csg/surface_count.png" src="../../images/efficient_csg/surface_count.png" style="width: 500px;"><p class="caption">The same intersection arrays from above and the corresponding surface_count array</p>
</div>
<p>To create surface_count we'll do the following:</p>
<ol class="arabic simple">
<li><p>Create a concatenated array of both hit arrays (but do not sort it yet).</p></li>
<li><p>Take the argsort of the concatenated array.</p></li>
<li><p>Create a new array with the same dimension as the concatenated array. For each index in the new array, assign +1 if the value in the equivalent argsort index is even, and -1 if is odd.</p></li>
<li><p>Take the cumulative sum of the +/-1 array, this is the surface count array.</p></li>
<li><p>Sort the concatenated hit array.</p></li>
</ol>
<p>The +/-1 array is used to indicate if a hit is entering or exiting one of the two surfaces. Since both arrays have an even number of elements, every odd value of the concatenated array must enter a surface, and every even hit must exit. NumPy's <code>where</code>, combined with <code>argsort</code> and <code>cumsum</code> are all we need to create surface_count. Once we have that we're ready to tackle the first of our Boolean operators.</p>
<pre class="code python"><a name="rest_code_fdfc8ac1454543499385a481e192719f-1"></a><span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
<a name="rest_code_fdfc8ac1454543499385a481e192719f-2"></a><span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_fdfc8ac1454543499385a481e192719f-3"></a><span class="n">merged_array</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">merged_argsort</span><span class="p">]</span>
<a name="rest_code_fdfc8ac1454543499385a481e192719f-4"></a><span class="n">merged_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">merged_argsort</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<a name="rest_code_fdfc8ac1454543499385a481e192719f-5"></a><span class="n">surface_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">merged_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="union">
<h3><a class="toc-backref" href="#id6">Union</a></h3>
<img alt="/images/efficient_csg/union_count.png" class="align-center" src="../../images/efficient_csg/union_count.png" style="width: 500px;"><p>Take a look at the union operator and corresponding count values. Notice that union hits are any any index (n) where count[n-1]==0 and count[n]==1, or count[n-1]==1 and count[n]==0. This is the same as taking the exclusive or (XOR) of the array with a copy of itself shifted down by one row. From above we know that the last value of the count array has to be 0 (at <span class="math">\(t=\infty\)</span> the ray must have exited all surfaces), so the zeroth row of the shifted array will always be all zeros. NumPy gives us all the function calls needed to efficiently perform xor on our count array, shown below.</p>
<pre class="code python"><a name="rest_code_a7ace20142bc474994e0131b54291ef7-1"></a><span class="n">surface_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">surface_count</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">surface_count</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<a name="rest_code_a7ace20142bc474994e0131b54291ef7-2"></a><span class="n">csg_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">surface_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">merged_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
</pre>
<p>A couple things from this code might pop out: (1) why specify the axis when rolling a 1D array, and (2) why does csg_hits need the same dimension as hit_array, padded with np.inf, and not just return the valid hits. Both of these are addressed in <a class="reference internal" href="#extending-to-2d-matrices">Extending To 2D Matrices</a>.</p>
</div>
<div class="section" id="intersection">
<h3><a class="toc-backref" href="#id7">Intersection</a></h3>
<img alt="/images/efficient_csg/intersection_count.png" class="align-center" src="../../images/efficient_csg/intersection_count.png" style="width: 500px;"><p>The intersection operator can be handled in a similar manner. Looking at the count array, an intersection hit occurs at any index (n) where count[n] == 2 or count[n-1] == 2. This time we'll use NumPy's <code>logical_or</code> function to create the mask.</p>
<pre class="code python"><a name="rest_code_b030d4e8bebc4bd4b312ea70f47f2e67-1"></a><span class="n">is_two</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
<a name="rest_code_b030d4e8bebc4bd4b312ea70f47f2e67-2"></a><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">is_two</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">is_two</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<a name="rest_code_b030d4e8bebc4bd4b312ea70f47f2e67-3"></a><span class="n">csg_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">merged_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
</pre>
<p>The intersection operator has an interesting "blip" at t=5. This is because the ray intersects both surfaces at that time, but enters the first while exiting the second. Using integer math this becomes a 'zero thickness' shell, but it can cause unintended results when the hits are floating points and the surfaces overlap by a small amount.</p>
</div>
<div class="section" id="difference">
<h3><a class="toc-backref" href="#id8">Difference</a></h3>
<p>The difference operator is unique from the union and intersection operator. Both union and intersection have analogs in boolean algebra, (or the binary equivalent <em>and</em> and <em>or</em> operators). Boolean algebra, however, does not have the concept of subtraction. Not only that, but we can't use the clever tricks from the count array, since we need to know which surface is the subtracting surface, and the count array only tracks how many closed surfaces the ray is inside. Rather than creating an entirely new method just for differences, we're going to redefine what a difference means so it it behaves like a boolean operation.</p>
<p>Don't think of A-B as shape B cutting away from shape A, think of it as the intersection of A with the infinitely large volume of space where B <em>does not</em> exist, called <span class="math">\(\bar{B}\)</span>.</p>
<img alt="/images/efficient_csg/csg_difference.png" class="align-center" src="../../images/efficient_csg/csg_difference.png" style="width: 900px;"><p>Defining the function in this way lets us reuse the the same principle as the intersection operator, but first the count array has to be redefined for an inverted shape. An inverted shape still has to follow the assumptions from above, but the ray enters the shape at <span class="math">\(-\infty\)</span> and <em>exits</em> the shape at the first hit in the hit array. Similarly, the ray <em>enters</em> the shape at the last hit of the hit array, and exits at <span class="math">\(\infty\)</span>.</p>
<img alt="/images/efficient_csg/inverted_difference.png" class="align-center" src="../../images/efficient_csg/inverted_difference.png" style="width: 500px;"><p>Padding the intersection array with <span class="math">\(+/-\infty\)</span> is unnecessary (and NumPy arrays don't like to be resized). Instead, the following observations allow us to work with the unmodified array.</p>
<ul class="simple">
<li><p>The hit at <span class="math">\(-\infty\)</span> will always be the first hit in the sorted hits array, meaning the first value in the cumulative sum will <em>always</em> be a 1. This is the same as adding 1 to the count array and ignoring the hit at <span class="math">\(-\infty\)</span>.</p></li>
<li><p>The hit at <span class="math">\(+\infty\)</span> will always be the last hit in the sorted hits array. If we ignore it, the cumulative sum's final value will be 1 (since the ray is still inside of the inverted surface). However, looking at the Intersection operator, we only care about finding indices where count[n]==2, so we're safe to ignore it.</p></li>
<li><p>The pre-summed count array needs to be filled with +/-1 from 0:n, where n is the length of the first hit array, and -/+1 from n:-1. This will successfully "invert" the second shape, where hits that used to enter the surface now exit, and visa versa.</p></li>
</ul>
<p>With those observations in hand we're ready to create the count array for the difference operator, and once again NumPy's <code>logical_xor</code> will simplify the task.</p>
<pre class="code python"><a name="rest_code_a5e366664c3046818bf0d082cd5bc9d7-1"></a><span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">left_array</span><span class="p">,</span> <span class="n">right_array</span><span class="p">))</span>
<a name="rest_code_a5e366664c3046818bf0d082cd5bc9d7-2"></a><span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_a5e366664c3046818bf0d082cd5bc9d7-3"></a>
<a name="rest_code_a5e366664c3046818bf0d082cd5bc9d7-4"></a><span class="n">count_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">merged_argsort</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">,</span> <span class="n">merged_argsort</span><span class="o">&gt;=</span><span class="n">left_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<a name="rest_code_a5e366664c3046818bf0d082cd5bc9d7-5"></a><span class="n">count_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">count_array</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre>
<p>Here the xor operator is inverting the array mask for any indices in the argsort that reference the right_array.</p>
</div>
<div class="section" id="id1">
<span id="extending-to-2d-matrices"></span><h3><a class="toc-backref" href="#id9">Extending To 2D Matrices</a></h3>
<p><a class="reference external" href="https://github.com/rfrazier716/PyRayT">PyRayT</a> can perform reasonably fast ray tracing because under the hood every ray is stored in a 2x4xn matrix that gets intersected with each surface. This allows me to bypass Python for loops in favor of heavily optimized NumPy functions. Fortunately, by specifying axes and preserving array sizes, the csg function can be readily extended to 2D matrices, where every column represents the ordered hits for an individual ray with the given surface.</p>
<p>The only thing we need to change is how the arrays are concatenated. If a 1D array is passed, they can be concatenated along the zero axis, but 2D arrays need to be stacked column-wise.</p>
<pre class="code python"><a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-1"></a><span class="k">if</span> <span class="n">array1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-2"></a>    <span class="c1"># if 1D arrays were passed, concatenate</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-3"></a>    <span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-4"></a>    <span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-5"></a>    <span class="n">merged_array</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">merged_argsort</span><span class="p">]</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-6"></a>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-7"></a><span class="k">else</span><span class="p">:</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-8"></a>    <span class="c1"># otherwise stack them where each column represents a unique ray's hits</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-9"></a>    <span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-10"></a>    <span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_c9407d0710314a0d83c7d14a1592b5c3-11"></a>    <span class="n">merged_array</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">merged_argsort</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">merged_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
</pre>
</div>
</div>
<div class="section" id="the-full-function">
<h2><a class="toc-backref" href="#id10">The Full Function</a></h2>
<p>The complete function is shown below. There's an additional helper class <code>Operation</code> that inherits from Enum used to select which CSG operation is performed (I prefer Enums over string arguments for anything end users won't see). There's an additional argument <code>sort_output</code> that sets if the returned array is sorted along the hit axis. The reason for this option is to eliminate unnecessary <code>np.sort()</code> calls on large arrays that slow down the final program.</p>
<pre class="code python"><a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-1"></a><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-2"></a><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-3"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-4"></a><span class="k">class</span> <span class="nc">Operation</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-5"></a>    <span class="n">UNION</span> <span class="o">=</span> <span class="mi">1</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-6"></a>    <span class="n">INTERSECT</span> <span class="o">=</span> <span class="mi">2</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-7"></a>    <span class="n">DIFFERENCE</span> <span class="o">=</span> <span class="mi">3</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-8"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-9"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-10"></a><span class="k">def</span> <span class="nf">array_csg</span><span class="p">(</span><span class="n">array1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">array2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">sort_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-11"></a>    <span class="sd">"""</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-12"></a><span class="sd">    Given two arrays and an operation, returns a new array which is the CSG operation acting on the array.</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-13"></a><span class="sd">    If the array is thought of as intersection points between a ray and a two objects being combined with a CSG</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-14"></a><span class="sd">    operation, the returned is the valid hits for the resulting object. Function assumes both arrays are sorted and have</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-15"></a><span class="sd">    an even number of axis=0 elements</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-16"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-17"></a><span class="sd">    :param array1:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-18"></a><span class="sd">    :param array2:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-19"></a><span class="sd">    :param operation:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-20"></a><span class="sd">    :return:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-21"></a><span class="sd">    """</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-22"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-23"></a>    <span class="k">if</span> <span class="n">array1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-24"></a>        <span class="c1"># if 1D arrays were passed, concatenate</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-25"></a>        <span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-26"></a>        <span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-27"></a>        <span class="n">merged_array</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">merged_argsort</span><span class="p">]</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-28"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-29"></a>    <span class="k">else</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-30"></a>        <span class="c1"># otherwise stack them where each column represents a unique ray's hits</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-31"></a>        <span class="n">merged_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-32"></a>        <span class="n">merged_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">merged_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-33"></a>        <span class="n">merged_array</span> <span class="o">=</span> <span class="n">merged_array</span><span class="p">[</span><span class="n">merged_argsort</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">merged_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-34"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-35"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-36"></a>    <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">UNION</span> <span class="ow">or</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-37"></a>        <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">merged_argsort</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-38"></a>        <span class="n">surface_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">merged_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-39"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-40"></a>    <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">DIFFERENCE</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-41"></a>        <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">merged_argsort</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">merged_argsort</span> <span class="o">&gt;=</span> <span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-42"></a>        <span class="n">surface_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">merged_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-43"></a>    <span class="k">else</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-44"></a>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"operation </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2"> is invalid"</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-45"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-46"></a>    <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">UNION</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-47"></a>        <span class="n">surface_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">surface_count</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">surface_count</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-48"></a>        <span class="n">csg_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">surface_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">merged_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-49"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-50"></a>    <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">INTERSECT</span> <span class="ow">or</span> <span class="n">operation</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">DIFFERENCE</span><span class="p">:</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-51"></a>        <span class="n">is_two</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-52"></a>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">is_two</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">is_two</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-53"></a>        <span class="n">csg_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">merged_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-54"></a>
<a name="rest_code_cfeeeda79f7a4610a93e51963d13eed5-55"></a>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">csg_hits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">sort_output</span> <span class="k">else</span> <span class="n">csg_hits</span>
</pre>
<div class="section" id="verifying-test-cases">
<h3><a class="toc-backref" href="#id11">Verifying Test Cases</a></h3>
<p>Before passing this function off as complete, we need to make sure it passes some basic unit tests. I'll be using Python's <a class="reference external" href="https://docs.python.org/3/library/unittest.html">UnitTest</a> framework to verify that the two hit arrays plotted above return the correct values for union, intersection, and difference.</p>
<pre class="code python"><a name="rest_code_651baec1fb16456fb0d4733d8b881f87-1"></a><span class="kn">import</span> <span class="nn">unittest</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-2"></a><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-3"></a><span class="kn">import</span> <span class="nn">csg</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-4"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-5"></a><span class="k">class</span> <span class="nc">TestArrayCSGOperation</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-6"></a>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-7"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">array1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-8"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">array2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-9"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-10"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-11"></a>    <span class="k">def</span> <span class="nf">test_add_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-12"></a>        <span class="n">unioned</span> <span class="o">=</span> <span class="n">csg</span><span class="o">.</span><span class="n">array_csg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array2</span><span class="p">,</span> <span class="n">csg</span><span class="o">.</span><span class="n">Operation</span><span class="o">.</span><span class="n">UNION</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-13"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-14"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unioned</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">unioned</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-15"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-16"></a>    <span class="k">def</span> <span class="nf">test_intersection_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-17"></a>        <span class="n">intersected</span> <span class="o">=</span> <span class="n">csg</span><span class="o">.</span><span class="n">array_csg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array2</span><span class="p">,</span> <span class="n">csg</span><span class="o">.</span><span class="n">Operation</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-18"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-19"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">intersected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">intersected</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-20"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-21"></a>    <span class="k">def</span> <span class="nf">test_diff_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-22"></a>        <span class="n">diffed</span> <span class="o">=</span> <span class="n">csg</span><span class="o">.</span><span class="n">array_csg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array2</span><span class="p">,</span> <span class="n">csg</span><span class="o">.</span><span class="n">Operation</span><span class="o">.</span><span class="n">DIFFERENCE</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-23"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-24"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diffed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expected</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">diffed</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-25"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-26"></a>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-27"></a><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
<a name="rest_code_651baec1fb16456fb0d4733d8b881f87-28"></a>    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre>
<p>With those tests passing, we're one step closer to a fully fledged Python ray tracer!</p>
<div class="container.fluid">
    <div class="row">
        <div class="col-md-8 my-auto">
        <p>
            Constructive Solid Geometry can extend the functionality of a ray tracer by building complex shapes from basic primitives, but rendering them requires an additional step to filter out which intersections are valid. Thanks to NumPy, it's easy to write this function without reverting to Python for loops, and the same function can be used to process multiple ray-surface intersections at once.
        </p>
        <p>
            In PyRayT, all lenses are CSG intersections of two spheres (defining the focus) and a cylinder that sets the aperture. This has sped up development time and is significantly easier than writing custom functions for each optical component.
        </p>
</div>
        <div class="col-md-4">
            <img src="../../images/efficient_csg/csg_in_action.png" alt="a cool looking, albeit meaningless example of CSG in action">
</div>
    </div>
</div>
<p class="alert alert-primary">You may have noticed the shading in these CSG surfaces seems a bit <em>off</em>. They're rendered with what's called a <a class="reference external" href="https://en.wikipedia.org/wiki/Gooch_shading">Gooch shader</a>, which is specifically designed to be non-photorealistic. In my next post I'll discuss adding Gooch shading to PyRayT, and its tradeoffs compared to other shader models.</p>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/constructive-solid-geometry/" rel="tag">constructive solid geometry</a></li>
            <li><a class="tag p-category" href="../../categories/csg/" rel="tag">csg</a></li>
            <li><a class="tag p-category" href="../../categories/numpy/" rel="tag">numpy</a></li>
            <li><a class="tag p-category" href="../../categories/pyrayt/" rel="tag">pyrayt</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/ray-tracing/" rel="tag">ray tracing</a></li>
            <li><a class="tag p-category" href="../../categories/rendering/" rel="tag">rendering</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../getting-up-and-running-with-nikola/" rel="prev" title="Getting Up and Running with Nikola">Previous post</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script></article><!--End of body content--><footer id="footer">
            
Contents © 2021         <a href="mailto:rfrazier716+site@gmail.com">Ryan Frazier</a> 
- Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         

<span class="follow-icons">

  <a href="mailto:rfrazier716+site@gmail.com" class="fas fa-envelope-square fa-2x follow-icon"></a>
  <a href="https://github.com/rfrazier716" class="fab fa-github-square fa-2x follow-icon"></a>
  <a href="https://www.instagram.com/fotonix716/" class="fab fa-instagram-square fa-2x follow-icon"></a>
  <a href="https://twitter.com/FotonixAndGizmo" class="fab fa-twitter-square fa-2x follow-icon"></a>
</span>

            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script src="https://kit.fontawesome.com/b9c0b6e7c8.js" crossorigin="anonymous"></script><!-- Go to www.addthis.com/dashboard to customize your tools --><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-603c029f21971de0"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
